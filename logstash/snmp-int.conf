### Uses if & ifxmibs, poe separate
### Enrich as necessary with Asset info / hostname etc
### this will poll intergace and 

input {
    snmp {
        hosts => [ 
            { host => "udp:192.168.1.1/161" community => "${SNMP_RO}" },
            { host => "udp:192.168.1.3/161" community => "${SNMP_RO}" },
            { host => "udp:192.168.1.5/161" community => "${SNMP_RO}" },
            { host => "udp:192.168.1.6/161" community => "${SNMP_RO}" },
            { host => "udp:192.168.1.7/161" community => "${SNMP_RO}" }
            ]
        tables => [
            ## ifmib & ifxMib Stats, POE stats if available
            {   "name" => "interfaces"
                "columns" => [  
                   ##IFMib
                    "1.3.6.1.2.1.2.2.1.2",
                   "1.3.6.1.2.1.2.2.1.3",
                   "1.3.6.1.2.1.2.2.1.4",
                   "1.3.6.1.2.1.2.2.1.5",
                   "1.3.6.1.2.1.2.2.1.6",
                   "1.3.6.1.2.1.2.2.1.7",
                   "1.3.6.1.2.1.2.2.1.8",
                   "1.3.6.1.2.1.2.2.1.9",
                   "1.3.6.1.2.1.2.2.1.10",
                   "1.3.6.1.2.1.2.2.1.11",
                   "1.3.6.1.2.1.2.2.1.13",
                   "1.3.6.1.2.1.2.2.1.14",
                   "1.3.6.1.2.1.2.2.1.15",
                   "1.3.6.1.2.1.2.2.1.16",
                   "1.3.6.1.2.1.2.2.1.17",
                   "1.3.6.1.2.1.2.2.1.18",  
                    ##IFxMib
                   "1.3.6.1.2.1.31.1.1.1.1",
                   "1.3.6.1.2.1.31.1.1.1.2",
                   "1.3.6.1.2.1.31.1.1.1.3",
                   "1.3.6.1.2.1.31.1.1.1.4",
                   "1.3.6.1.2.1.31.1.1.1.5",
                   "1.3.6.1.2.1.31.1.1.1.6",
                   "1.3.6.1.2.1.31.1.1.1.7",
                   "1.3.6.1.2.1.31.1.1.1.8",
                   "1.3.6.1.2.1.31.1.1.1.9",
                   "1.3.6.1.2.1.31.1.1.1.10",
                   "1.3.6.1.2.1.31.1.1.1.11",
                   "1.3.6.1.2.1.31.1.1.1.12",
                   "1.3.6.1.2.1.31.1.1.1.13",
                   "1.3.6.1.2.1.31.1.1.1.15",
                   "1.3.6.1.2.1.31.1.1.1.16",
                   "1.3.6.1.2.1.31.1.1.1.17",
                   "1.3.6.1.2.1.31.1.1.1.18"
                ]
            }
        ]
        ## the standard logstash install should have the mibs for these items
        ## this will keep the last 3 mib names
        oid_path_length => 3
        interval => 60
    }
}

filter {

    mutate {
        ## Add basic ECS fields
        add_field => {
            "[event][kind]" => "metric" 
            "[event][category]" => "host" 
            "[event][type]" => "info" 
            "[event][dataset]" => "snmp.interfaces"
            "[event][module]" => "snmp"
            "[agent][type]" => "logstash"
            "[agent][version]" => "7.12.0"
            ## agent info can be dynamically set via env variables or keystore per system
            "[agent][name]" => "my_snmp_poller_name"
            "[agent][ip]" => "my_snmp_poller_ip"
        }
        rename => {
            "[host]" => "[host][ip]"
        }
    }   

    split { field => "interfaces" }

    mutate {
        rename => {
            "[interfaces][ifEntry.ifAdminStatus]" => "[interface][enabled]"
            "[interfaces][ifEntry.ifDescr]" => "[interface][description]"
            "[interfaces][ifEntry.ifInDiscards]" => "[interface][in][discards]"
            "[interfaces][ifEntry.ifInErrors]" => "[interface][in][errors]"
            "[interfaces][ifEntry.ifInUnknownProtos]" => "[interface][in][unknown]"
            "[interfaces][ifEntry.ifLastChange]" => "[interface][last_changed]"
            "[interfaces][ifEntry.ifMtu]" => "[interface][mtu]"
            "[interfaces][ifEntry.ifOperStatus]" => "[interface][up]"
            "[interfaces][ifEntry.ifPhysAddress]" => "[interface][mac]"
            "[interfaces][ifEntry.ifType]" => "[interface][type]"
            "[interfaces][ifXEntry.ifAlias]" => "[interface][alias]"
            "[interfaces][ifXEntry.ifHCInBroadcastPkts]" => "[interface][in][packets][broadcast]"
            "[interfaces][ifXEntry.ifHCInMulticastPkts]" => "[interface][in][packets][multicast]"
            "[interfaces][ifXEntry.ifHCInOctets]" => "[interface][in][bytes]"
            "[interfaces][ifXEntry.ifHCInUcastPkts]" => "[interface][in][packets][unicast]"
            "[interfaces][ifXEntry.ifHCOutBroadcastPkts]" => "[interface][out][packets][broadcast]"
            "[interfaces][ifXEntry.ifHCOutMulticastPkts]" => "[interface][out][packets][multicast]"
            "[interfaces][ifXEntry.ifHCOutOctets]" => "[interface][out][bytes]"
            "[interfaces][ifXEntry.ifHCOutUcastPkts]" => "[interface][out][packets][unicast]"
            "[interfaces][ifXEntry.ifHighSpeed]" => "[interface][speed]"
            "[interfaces][ifXEntry.ifName]" => "[interface][name]"
            "[interfaces][index]" => "[interface][index]"
        }
        remove_field => [ "interfaces" ]
    }

    ## Conver SNMP 1/2 to boolean
    if [interface][enabled] == 1 {
        mutate { replace => { "[interface][enabled]" => true } }
    }
    else {
        mutate { replace => { "[interface][enabled]" => false } }
    }

    if [interface][up] == 1 {
        mutate { replace => { "[interface][up]" => true } }
    }

    else {
        mutate { replace => { "[interface][up]" => false } }
    }
}


output {
    ## should be more specific to look for failure / error, etc.
    if [tags] {
        file {
           path => "/var/log/logstash/snmp-int-errors.json"
        }
    }

    elasticsearch {
        hosts => "${ES_URL}"
        user => "${ES_USER}"
        password => "${ES_PW}"
        index => "snmp"
    }
}